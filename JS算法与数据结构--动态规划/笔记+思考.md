## 动态规划(Dynamic Programming，DP)
#### 动态规划，就是利用上一次的计算结果，来避免我们的重复劳动。同时，我们需要⼀些变量来保存，⼀般是⼀维数组或者⼆维数组

#### FIRST
    定义数组元素的含义，即用⼀个数组，来保存历史信息。

    先建立⼀维数组dp[]，然后规定这个数组元素的含义。
#### SECOND
    找出数组元素之间的关系。

    当我们要计算 dp[n] 时，是可以利⽤ dp[n-1]，dp[n-2].....dp[1]，来推出 dp[n] 的。

    举个例子 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。
#### THIRD
    找出初始值。

    虽然我们知道了数组元素之间的关系式如dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]。

    但是，我们必须要知道初始值，也就是递归结束的条件。

    假如⼀直推下去的话，可以得到dp[3] = dp[2] + dp[1]。但是 dp[2] 和 dp[1] 是无法继续递归的，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值。
    
    有了初始值以及数组元素之间的关系式，那么我们就可以得到 dp[n] 的值了。其中dp[n] 的含义是根据题目而定的。
### 举例：背包问题

**题目**：有一个容量为 V 的背包，和一些物品。这些物品分别有两个属性，体积 w 和价值 v，每种物品只有一个。要求用这个背包装下价值尽可能多的物品，求该最大价值，背包可以不被装满。 

**分析**：

1. 初始化二维数组dp[i][j], 规定其含义为：**背包容量为j时，求前i个物品所能达到最大价值**
2. 找关系：  
**dp[i][j] = max{ values + dp[i-1][j - weights[i]], dp[i-1][j] }**   
以及  
**dp[i][j] = dp[i-1][j]**  
其含义是： 和不放入当前物品时 同样达到该体积的 最大价值比较

**参考代码**：详见 [参考代码](./背包问题.html)
